//! Interact with an existing Counter contract

use alloy::{
    primitives::{Address, FixedBytes, U256},
    sol,
};

use alloy_transport::Transport;
use eyre::Result;
use futures_util::StreamExt;
use ICounter::NumberChanged;

use crate::counter_existing::ICounter::ICounterInstance;

// Counter interface: not getNumberPlus17 and number do not have defined return values.
sol! {
    // We need the bytecode for event streams.
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "0x6080604052348015600e575f80fd5b5061030a8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610055575f3560e01c8063273e24311461005957806339cd20ab146100775780633fb5c1cb146100955780638381f58a146100b1578063d09de08a146100cf575b5f80fd5b6100616100d9565b60405161006e91906101bb565b60405180910390f35b61007f6100ed565b60405161008c91906101bb565b60405180910390f35b6100af60048036038101906100aa9190610202565b610101565b005b6100b9610186565b6040516100c691906101bb565b60405180910390f35b6100d761018b565b005b5f60115f546100e8919061025a565b905090565b5f60115f546100fc919061025a565b905090565b805f540361014657806040517fb305b7e600000000000000000000000000000000000000000000000000000000815260040161013d91906101bb565b60405180910390fd5b7f2fd81fd19d3c5c4b396dd13f451dafc8bcac1b3094c49c5fa90e68456323f0e38160405161017591906101bb565b60405180910390a1805f8190555050565b5f5481565b5f8081548092919061019c9061028d565b9190505550565b5f819050919050565b6101b5816101a3565b82525050565b5f6020820190506101ce5f8301846101ac565b92915050565b5f80fd5b6101e1816101a3565b81146101eb575f80fd5b50565b5f813590506101fc816101d8565b92915050565b5f60208284031215610217576102166101d4565b5b5f610224848285016101ee565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610264826101a3565b915061026f836101a3565b92508282019050808211156102875761028661022d565b5b92915050565b5f610297826101a3565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036102c9576102c861022d565b5b60018201905091905056fea264697066735822122054dd587ec1aab2b817b4865e6d1de375e7b5d614d40c50898fa5f6119776c0a664736f6c634300081a0033")]
    interface ICounter {
        error NoChange(uint256 _val);
        #[derive(Debug)]
        event NumberChanged(uint256 _val);

        function setNumber(uint256 _newNumber) external;
        function increment() external;
        function number() external view returns(uint256);
        function getNumberPlus17() external view returns(uint256);
        function getNumberPlus17a() external view returns(uint256 numPlus17);
    }
}

#[derive(Clone)]
pub struct CounterExisting<T, P> {
    pub token_contract: ICounterInstance<T, P>,
}

impl<T, P> CounterExisting<T, P>
where
    T: Transport + Clone,
    P: alloy_provider::Provider<T>,
{
    pub async fn new(token_address: Address, provider: P) -> Result<Self> {
        let token_contract = ICounter::new(token_address, provider);
        Ok(Self { token_contract })
    }

    pub async fn address(&self) -> Result<&Address> {
        let addr = self.token_contract.address();
        Ok(addr)
    }

    pub async fn set_number(&self, value: U256) -> Result<FixedBytes<32>> {
        let builder = self.token_contract.setNumber(U256::from(value));
        let tx_hash = builder.send().await?.watch().await?;
        Ok(tx_hash)
    }

    pub async fn increment(&self) -> Result<FixedBytes<32>> {
        let builder = self.token_contract.increment();
        let tx_hash = builder.send().await?.watch().await?;
        Ok(tx_hash)
    }

    pub async fn number(&self) -> Result<U256> {
        let builder = self.token_contract.number();
        // Note: because the artifact generated by `solc` does not include named return values it is
        // not possible to derive the return value name `number` from the artifact. This means that the
        // return value must be accessed by index - as if it is an unnamed value.
        // If you prefer to use named return values, it is recommended to embed the Solidity code
        // directly in the `sol!` macro as shown in `deploy_from_contract.rs`.
        let value = builder.call().await?._0;
        Ok(value)
    }

    pub async fn get_number_plus17(&self) -> Result<U256> {
        let res = self.token_contract.getNumberPlus17().call().await?._0;
        Ok(res)
    }

    pub async fn get_number_plus17a(&self) -> Result<U256> {
        let res = self
            .token_contract
            .getNumberPlus17a()
            .call()
            .await?
            .numPlus17;
        Ok(res)
    }

    pub async fn wait_for_event(&self) -> Result<NumberChanged> {
        let event_filter = self.token_contract.NumberChanged_filter().watch().await?;
        let mut event_stream = event_filter.into_stream();
        let a = event_stream.next().await.ok_or(eyre::eyre!("No event"))?;
        Ok(a?.0)
    }
}
